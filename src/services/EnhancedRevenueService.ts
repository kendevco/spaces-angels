import type { Payload } from 'payload'
import type { Tenant, Product, Appointment } from '@/payload-types'
import { getPayload } from 'payload'
import configPromise from '@payload-config'

interface ProductCommissionCalculation {
  productId: string
  baseRate: number
  customRate?: number
  sourceMultiplier: number
  effectiveRate: number
  source: string
  commissionAmount: number
  netAmount: number
}

interface ImmediatePayoutResult {
  success: boolean
  platformCommission: number
  netAmount: number
  stripeTransferId?: string
  error?: string
}

type AppointmentSource = 'system_generated' | 'pickup_job' | 'referral_source' | 'repeat_customer'

export class EnhancedRevenueService {
  private payload: Payload | null = null

  constructor() {
    this.initializePayload()
  }

  private async initializePayload() {
    this.payload = await getPayload({ config: configPromise })
  }

  /**
   * Calculate commission for specific product/service with source consideration
   * This handles your requirement for intrinsic product percentages + source multipliers
   */
  async calculateProductCommission(
    tenantId: string,
    productId: string,
    amount: number,
    source: AppointmentSource = 'system_generated'
  ): Promise<ProductCommissionCalculation> {
    if (!this.payload) await this.initializePayload()

    // Get tenant and product data
    const [tenant, product] = await Promise.all([
      this.payload!.findByID({ collection: 'tenants', id: tenantId }) as Promise<Tenant>,
      this.payload!.findByID({ collection: 'products', id: productId }) as Promise<Product>
    ])

    // Determine base rate (product custom rate or tenant default)
    const baseRate = (product as any).commission?.useCustomRate
      ? (product as any).commission.customCommissionRate
      : tenant.revenueSharing?.revenueShareRate || 3.0

    // Get source multiplier from product configuration
    const sourceMultipliers = (product as any).commission?.sourceMultipliers || {}
    let sourceMultiplier = 1.0

    switch (source) {
      case 'system_generated':
        sourceMultiplier = sourceMultipliers.systemGenerated || 1.0
        break
      case 'pickup_job':
        sourceMultiplier = sourceMultipliers.pickupJob || 0.5 // Half rate for self-acquired
        break
      case 'referral_source':
        sourceMultiplier = sourceMultipliers.referralSource || 1.5 // 150% for referrals
        break
      case 'repeat_customer':
        sourceMultiplier = sourceMultipliers.repeatCustomer || 0.8 // Slightly lower for repeat
        break
    }

    // Apply partnership tier adjustments
    const tierMultiplier = this.getPartnershipTierMultiplier(tenant.revenueSharing?.partnershipTier || undefined)
    const effectiveRate = baseRate * sourceMultiplier * tierMultiplier

    const commissionAmount = (amount * effectiveRate) / 100
    const netAmount = amount - commissionAmount

    return {
      productId,
      baseRate,
      customRate: (product as any).commission?.useCustomRate ? (product as any).commission.customCommissionRate : undefined,
      sourceMultiplier,
      effectiveRate,
      source,
      commissionAmount,
      netAmount
    }
  }

  /**
   * Process immediate commission distribution via Stripe Connect
   * All funds generated by system are immediately available to recipient
   */
  async processImmediateCommission(
    tenantId: string,
    productId: string,
    amount: number,
    source: AppointmentSource,
    stripePaymentIntentId: string
  ): Promise<ImmediatePayoutResult> {
    try {
      const commissionCalc = await this.calculateProductCommission(tenantId, productId, amount, source)

      // Get tenant's Stripe connected account
      const tenant = await this.payload!.findByID({ collection: 'tenants', id: tenantId }) as Tenant
      const stripeAccountId = (tenant as any).stripeConnect?.accountId

      if (!stripeAccountId) {
        return {
          success: false,
          platformCommission: commissionCalc.commissionAmount,
          netAmount: commissionCalc.netAmount,
          error: 'No Stripe connected account found'
        }
      }

      if (commissionCalc.netAmount <= 0) {
        return {
          success: false,
          platformCommission: commissionCalc.commissionAmount,
          netAmount: commissionCalc.netAmount,
          error: 'Net amount is zero or negative'
        }
      }

      // Create immediate transfer to tenant's connected account
      console.log(`[EnhancedRevenueService] Processing immediate transfer:`)
      console.log(`  - Amount: $${amount.toFixed(2)}`)
      console.log(`  - Commission: $${commissionCalc.commissionAmount.toFixed(2)} (${commissionCalc.effectiveRate.toFixed(2)}%)`)
      console.log(`  - Net to recipient: $${commissionCalc.netAmount.toFixed(2)}`)
      console.log(`  - Source: ${source} (${commissionCalc.sourceMultiplier}x multiplier)`)
      console.log(`  - Stripe Account: ${stripeAccountId}`)

      // TODO: Implement actual Stripe transfer
      // const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY)
      // const transfer = await stripe.transfers.create({
      //   amount: Math.round(commissionCalc.netAmount * 100), // Convert to cents
      //   currency: 'usd',
      //   destination: stripeAccountId,
      //   transfer_group: stripePaymentIntentId,
      //   description: `Revenue for ${source} appointment - Product: ${productId}`,
      // })

      // For now, simulate successful transfer
      const mockTransferId = `tr_mock_${Date.now()}`

      // Log commission record
      await this.createCommissionRecord({
        tenantId,
        amount: commissionCalc.commissionAmount,
        type: 'platform',
        period: new Date().toISOString().substring(0, 7), // YYYY-MM
        status: 'paid',
        productId,
        source,
      })

      return {
        success: true,
        platformCommission: commissionCalc.commissionAmount,
        netAmount: commissionCalc.netAmount,
        stripeTransferId: mockTransferId
      }

    } catch (error) {
      console.error(`[EnhancedRevenueService] Failed to process immediate commission:`, error)
      return {
        success: false,
        platformCommission: 0,
        netAmount: amount,
        error: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  }

  /**
   * Update appointment with calculated commission based on source
   */
  async updateAppointmentCommission(
    appointmentId: string,
    productId?: string,
    amount?: number
  ): Promise<void> {
    if (!this.payload) await this.initializePayload()

    try {
      const appointment = await this.payload!.findByID({
        collection: 'appointments',
        id: appointmentId
      }) as Appointment

      if (!appointment) return

      // Fix tenant ID type handling
      const tenantId = typeof appointment.tenant === 'object' ? appointment.tenant.id : appointment.tenant
      const source = (appointment as any).revenueTracking?.source || 'system_generated'
      const paymentAmount = amount || (appointment.payment?.amount || 0)

      if (productId && paymentAmount > 0 && tenantId) {
        const commissionCalc = await this.calculateProductCommission(
          String(tenantId), // Convert to string
          productId,
          paymentAmount / 100, // Convert from cents
          source
        )

        // Log commission calculation - don't try to update non-existent revenueTracking field
        console.log(`[EnhancedRevenueService] Calculated commission for appointment ${appointmentId}:`)
        console.log(`  - Commission Rate: ${commissionCalc.effectiveRate.toFixed(2)}%`)
        console.log(`  - Commission Amount: $${commissionCalc.commissionAmount.toFixed(2)}`)
        console.log(`  - Source: ${source} (${commissionCalc.sourceMultiplier}x)`)

        // Store commission data in separate record instead of updating appointment
        await this.createCommissionRecord({
          tenantId: String(tenantId), // Convert to string
          amount: commissionCalc.commissionAmount,
          type: 'platform',
          period: new Date().toISOString().substring(0, 7),
          status: 'pending', // Use valid status
          productId,
          source,
        })
      }
    } catch (error) {
      console.error(`[EnhancedRevenueService] Failed to update appointment commission:`, error)
    }
  }

  /**
   * Get partnership tier multiplier for rate adjustments
   */
  private getPartnershipTierMultiplier(tier?: string): number {
    switch (tier) {
      case 'strategic':
        return 0.7  // 30% discount
      case 'enterprise':
        return 0.6  // 40% discount
      case 'preferred':
        return 0.85 // 15% discount
      case 'referral_source':
        return 0.5  // 50% discount (they bring business)
      case 'standard':
      default:
        return 1.0  // No discount
    }
  }

  /**
   * Create commission payment record
   */
  private async createCommissionRecord(payment: {
    tenantId: string
    amount: number
    type: 'platform' | 'referral'
    period: string
    status: 'pending' | 'paid' | 'failed'
    productId?: string
    source?: string
  }): Promise<void> {
    console.log(`[EnhancedRevenueService] Commission Record:`, {
      tenant: payment.tenantId,
      amount: `$${payment.amount.toFixed(2)}`,
      type: payment.type,
      period: payment.period,
      status: payment.status,
      product: payment.productId,
      source: payment.source
    })

    // TODO: Create CommissionPayments collection to track these
    // For now, we log them for audit trail
  }

  /**
   * Get comprehensive revenue analytics for a tenant
   */
  async getRevenueAnalytics(tenantId: string): Promise<{
    totalRevenue: number
    platformCommissions: number
    netRevenue: number
    sourceBreakdown: Record<string, { revenue: number, commission: number }>
  }> {
    // This would aggregate data from appointments, orders, etc.
    // For now, return mock data structure
    return {
      totalRevenue: 0,
      platformCommissions: 0,
      netRevenue: 0,
      sourceBreakdown: {}
    }
  }
}
